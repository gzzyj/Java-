#五种IO模型
## 概念说明
### 内核空间和用户空间
现在的操作系统都采用虚拟存储器。操作系统的核心是内核，独立于普通应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。 为了保证用户进程不能直接操作内核，保证内核的安全，操作系统将虚拟空间划分为两部分。 一部分供内核使用，称为内核空间；一部分供各个进程使用，称为用户空间。

###  进程切换
内核能够控制进程的执行。1、可以挂起当前正在执行的进程；2、可以回复先前挂起的某个进程。挂起当前进程，执行另一个进程称之为进程切换。   
进程的切换需要内核执行一下操作： 
>1、 保存当前正在执行进程的上下文。      
>2、更新当前进程的进程管理块。
>3、将当前进程的管理块移入相应的队列，比如就绪、在某个事件上阻塞等队列。  
>4、选择另外一个进程执行，并更新这个进程的管理块 。  
>5、更新内存管理的数据结构。  
>6、恢复新进程的上下文。  
 
### 进程阻塞
正在运行的进程，由于某些期待的事件未发生，则有系统自动执行阻塞原语，使自己有运行态转为阻塞态。进程期待的事件可能有下列几类：新数据尚未到达，无新工作，请求系统资源失败或者等待某种操作完成等。当进程进入阻塞状态, 不会占用cpu资源。    
### 文件描述符
文件描述符是用于描述指向文件的引用的抽象化概念。对于类Unix、Linux操作系统而言， 当进程每次打开一个文件，或创建一个文件时， 内核向进程返回一个文件描述符。   
### 缓存IO
缓存IO也被称之为标准IO，大多数操作系统的默认IO操作都是缓存IO。 在Linux的缓存IO机制中，操作系统会先把IO的数据缓存在文件系统的页缓存中（page cache），即，应用程序读取IO数据，数据会先被拷贝到操作系统内核的缓冲区中， 之后再由内核缓冲区拷贝到应用程序的地址空间。 

### IO过程
对于一次IO读取
>第一阶段：等待数据准备 (Waiting for the data to be ready)。  
>第二阶段：将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)。

在网络IO的场景下： 
>第一步：通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。  
>第二步：把数据从内核缓冲区复制到应用进程缓冲区。  

## 阻塞IO
应用程序在调用系统函数读取数据时，如果数据还没有准备好，会阻塞住，数据读取过程也是同步阻塞的。 

## 非阻塞IO
应用程序在读取数据时，如果数据没有准备好，会立即返回。如果数据准备好了，需要同步读取。 相比于`阻塞IO`，如果数据还没有准备好，应用程序不必被阻塞住；不过仍需要应用程序一直查询数据的准备状态。 

## 多路IO复用
`非阻塞IO`解决了数据为准备好时，应用读取数据被阻塞的问题。 在并发环境下，由于`非阻塞IO`需要创建大量的线程监听每个IO数据是否准备好。这对应用程序来说，依然需要付出昂贵的代价。 

`多路IO复用`将对IO数据准备状态的轮询，由用户空间转到内核空间。应用程序只需要通过阻塞调用系统函数select/poll/epoll，函数通过返回文件描述符，应用便可查询到多个IO数据的准备状态。   

## 信号驱动IO
相比于`多路IO复用`对多个IO（fd）的暴力轮询，`信号驱动IO`不是用循环请求询问的方式去监控数据就绪状态，而是在调用sigaction时候建立一个SIGIO的信号联系，当内核数据准备好之后再通过SIGIO信号通知线程数据准备好后的可读状态，当线程收到可读状态的信号后，此时再向内核发起recvfrom读取数据的请求，因为信号驱动IO的模型下应用线程在发出信号监控后即可返回，不会阻塞，所以这样的方式下，一个应用线程也可以同时监控多个IO（fd）。

## 异步IO
`异步IO`不需要应用程序获取IO数据准备状态。`异步IO`在应用程序读取数据的时候就将处理数据的句柄传给内核，内核读取数据拷贝到应用空间后，直接返回到应用空间，在给定的句柄中处理数据。
